grammar;
use aleph_syntax_tree::syntax::AlephTree as at;

/// A COBOL program is composed of at least one division.
pub Program: at = {
    <divs:NonEmptyDivisionList> => at::Module {
        name: "COBOL_PROGRAM".to_string(),
        module_type: "program".to_string(),
        id: None,
        declarations: divs,
        body: None,
        initialization: None,
    }
}

/// A non-empty list of divisions.
pub NonEmptyDivisionList: Vec<Box<at>> = {
    <div:Division> => vec![Box::new(div)],
    <divs:NonEmptyDivisionList> <div:Division> => {
        let mut v = divs;
        v.push(Box::new(div));
        v
    }
}

/// A COBOL division.
pub Division: at = {
    <div:IdentificationDivision> => div,
    <div:EnvironmentDivision> => div,
    <div:DataDivision> => div,
    <div:ProcedureDivision> => div,
}

/// The IDENTIFICATION DIVISION.
pub IdentificationDivision: at = {
    "IDENTIFICATION" "DIVISION." <content:ParagraphList> => at::Division {
        division_type: "identification".to_string(),
        sections: content,
    }
}

/// The ENVIRONMENT DIVISION.
pub EnvironmentDivision: at = {
    "ENVIRONMENT" "DIVISION." <content:ParagraphList> => at::Division {
        division_type: "environment".to_string(),
        sections: content,
    }
}

/// The DATA DIVISION.
pub DataDivision: at = {
    "DATA" "DIVISION." <secs:ParagraphList> => at::Division {
        division_type: "data".to_string(),
        sections: secs,
    }
}

/// The PROCEDURE DIVISION.
pub ProcedureDivision: at = {
    "PROCEDURE" "DIVISION." <content:ParagraphList> => at::Division {
        division_type: "procedure".to_string(),
        sections: content,
    }
}

/// A COBOL section with a name and list of paragraphs.
pub Section: at = {
    <name:Ident> "SECTION." <content:ParagraphList> => at::Section {
        name,
        section_type: None,
        content,
    }
}

/// A list of paragraphs (can be empty).
pub ParagraphList: Vec<Box<at>> = {
    => Vec::new(),
    <ps:NonEmptyParagraphList> => ps,
}

/// A non-empty list of paragraphs.
pub NonEmptyParagraphList: Vec<Box<at>> = {
    <p:Paragraph> => vec![Box::new(p)],
    <ps:NonEmptyParagraphList> <p:Paragraph> => {
        let mut v = ps;
        v.push(Box::new(p));
        v
    }
}

/// A COBOL paragraph, composed of a name and one or more statements.
pub Paragraph: at = {
    <name:Ident> "." <stmts:StatementList> => at::ProcedureDef {
        name,
        proc_type: Some("paragraph".to_string()),
        parameters: Vec::new(),
        return_type: None,
        attributes: Vec::new(),
        declarations: Vec::new(),
        body: stmts,
    }
}

/// A list of statements (can be empty).
pub StatementList: Vec<Box<at>> = {
    => Vec::new(),
    <stmts:NonEmptyStatementList> => stmts,
}

/// A non-empty list of statements.
pub NonEmptyStatementList: Vec<Box<at>> = {
    <stmt:Statement> => vec![Box::new(stmt)],
    <stmts:NonEmptyStatementList> <stmt:Statement> => {
        let mut v = stmts;
        v.push(Box::new(stmt));
        v
    }
}

/// A COBOL statement (DISPLAY, MOVE, PERFORM, or IF).
pub Statement: at = {
    <stmt:DisplayStmt> => stmt,
    <stmt:MoveStmt> => stmt,
    <stmt:PerformStmt> => stmt,
    <stmt:IfStmt> => stmt,
}

/// The DISPLAY statement.
pub DisplayStmt: at = {
    "DISPLAY" <items:NonEmptyLiteralList> "." => at::Print {
        items,
        destination: None,
        format: None,
        options: Vec::new(),
    }
}

/// The MOVE statement.
pub MoveStmt: at = {
    "MOVE" <src:Ident> "TO" <dst:Ident> "." => at::Move {
        source: Box::new(at::Ident { value: src }),
        targets: vec![Box::new(at::Ident { value: dst })],
    }
}

/// The PERFORM statement (simple form, target only).
pub PerformStmt: at = {
    "PERFORM" <target:Ident> "." => at::Perform {
        target: Some(target),
        from: None,
        through: None,
        times: None,
        until: None,
        varying: None,
        inline: None,
    }
}

/// The IF statement.
/// An explicit trailing period is required to remove ambiguity.
pub IfStmt: at = {
    "IF" <cond:Condition> <then:NonEmptyStatementList> "." => at::If {
        condition: Box::new(cond),
        then: Box::new(at::Block { statements: then }),
        els: Box::new(at::Unit),
    }
}

/// A condition testing equality between two identifiers.
pub Condition: at = {
    <lhs:Ident> "=" <rhs:Ident> => at::Eq {
        expr1: Box::new(at::Ident { value: lhs }),
        expr2: Box::new(at::Ident { value: rhs }),
    }
}

/// A non-empty list of literals.
pub NonEmptyLiteralList: Vec<Box<at>> = {
    <lit:Literal> => vec![Box::new(lit)],
    <lits:NonEmptyLiteralList> <lit:Literal> => {
        let mut v = lits;
        v.push(Box::new(lit));
        v
    }
}

/// A literal value (string or identifier).
pub Literal: at = {
    <s:StringLiteral> => s,
    <i:Ident> => at::Ident { value: i },
}

/// A string literal between single quotes.
pub StringLiteral: at = {
    r#"'[^']*'"# => at::String {
        value: <>.to_string().trim_matches('\'').to_string(),
    }
}

/// An identifier: alphanumeric with optional hyphens.
pub Ident: String = {
    r#"[A-Za-z0-9-]+"# => <>.to_string(),
};
